{
  "articles": [
    {
      "path": "anatomy.html",
      "title": "Shiny Anatomy",
      "description": "The guts and connective tissue\n",
      "author": [],
      "contents": "\r\n\r\nContents\r\nGlobal\r\nUI & Server\r\nOutputs & Render\r\nInputs\r\n\r\n\r\nA Shiny app generally consists of three parts: the user interface (UI), the server, and a place for global variables.\r\nGlobal\r\nIn a single file app, packages and global variables can be loaded at the top of the script.\r\n\r\n\r\nlibrary(shiny)\r\nlibrary(tidyverse)\r\nlibrary(here)\r\n\r\ndf <- read_csv(here('data', 'babynames.csv'))\r\n\r\n\r\n\r\nUI & Server\r\nThe UI is comprised of R functions that will ultimately generate HTML–a markup language that structures and presents content for the web.\r\n\r\n\r\nui <- fluidPage(\r\n  \r\n  # static elements in the UI\r\n  titlePanel(\"U.S. Baby Names\"),\r\n  p(\"Source:\", \r\n    tags$a(href = \"https://www.ssa.gov/oact/babynames/limits.html\", \r\n           \"Social Security Administration\"))\r\n)\r\n\r\n\r\n\r\nStore elements of your UI inside fluidPage() separated by commas. You can use any of the following methods to build the UI:\r\nShiny UI functions (e.g. titlePanel())\r\nReference HTML tags using tag$ as a prefix (e.g tag$img()).\r\nFor a list of HTML tags: names(tags)\r\nThe most common tags are functions themselves and don’t require the prefix (e.g. p(), h1(), etc.)\r\n\r\nraw HTML within the wrapper html()\r\nOutputs & Render\r\nFunctions ending in *Output(), creates space(s) in the UI for R outputs, such as tables and plots. However, the UI can’t process and display R output by itself. It requires help from the server.\r\n\r\n\r\nui <- fluidPage(\r\n  \r\n  titlePanel(\"U.S. Baby Names\"),\r\n  p(\"Source:\", \r\n    tags$a(href = \"https://www.ssa.gov/oact/babynames/limits.html\", \r\n           \"Social Security Administration\")),\r\n  \r\n  # a place to display our data frame as a table. Its ID is 'main_table'\r\n  tableOutput(\"main_table\")\r\n  \r\n)\r\n\r\n\r\n\r\nFor every *Output() there must be a compatible render*() in the server. They work as pairs, connected by the unique name of the output, to add R output to the UI.\r\n\r\n\r\nserver <- function(input, output) {\r\n  \r\n  # render the r object `df` to the space called, 'main_table'.\r\n  output$main_table <- renderTable({\r\n    df %>% slice(1:20)\r\n    })\r\n}\r\n\r\n\r\n\r\nThe server is one large function that passes in inputs and outputs (and depending on what you’re doing, a session argument). output is inherent in Shiny–it is a list-like object referencing the outputs in the UI and additional code required to update each output object1.\r\nInputs\r\nWhat makes Shiny interactive are inputs. Input widgets such as text boxes, checkboxes, dropdown menus, buttons, and many others, collect values from the user.\r\nSimilar to *Output(), inputs also require a unique name. The unique inputID is what connects the front-end to the back-end.\r\n\r\n\r\nui <- fluidPage(\r\n  \r\n    titlePanel(\"U.S. Baby Names\"),\r\n    p(\"Source:\", \r\n      tags$a(href = \"https://www.ssa.gov/oact/babynames/limits.html\", \r\n             \"Social Security Administration\")),\r\n    \r\n    # A text box to enter a name. Its ID is 'name'.\r\n    textInput(\"name\", \r\n              label = \"Enter name\",\r\n              placeholder = \"Jane\"),\r\n    \r\n    tableOutput(\"main_table\")\r\n  \r\n)\r\n\r\n\r\n\r\nIn this example, we collect the user’s input value from textInput() and display it in the output area called name_entered.\r\n\r\n\r\nui <- fluidPage(\r\n  \r\n    titlePanel(\"U.S. Baby Names\"),\r\n    p(\"Source:\", \r\n      tags$a(href = \"https://www.ssa.gov/oact/babynames/limits.html\", \r\n             \"Social Security Administration\")),\r\n    \r\n    textInput(\"name\", \r\n              label = \"Enter name\",\r\n              placeholder = \"Jane\"),\r\n    \r\n    # Display the name that was entered in textInput\r\n    textOutput(\"name_entered\"),\r\n    \r\n    tableOutput(\"main_table\")\r\n  \r\n)\r\n\r\n\r\n\r\nServer-side, reference the input value with input$ as a prefix and the unique name of the input widget. input like output is inherent to Shiny. It is a list-like object containing all inputIDs from the UI.\r\n\r\n\r\nserver <- function(input, output) {\r\n  \r\n  # render the textInput to the designated output\r\n  output$name_entered <- renderText({\r\n    c(\"You entered:\", input$name)\r\n  })\r\n  \r\n  output$main_table <- renderTable({\r\n    df %>% slice(1:20)\r\n    })\r\n  \r\n   \r\n}\r\n\r\n\r\n\r\n\r\nhttps://shiny.rstudio.com/tutorial/written-tutorial/lesson4/↩︎\r\n",
      "last_modified": "2021-02-18T15:12:15-08:00"
    },
    {
      "path": "getting_started.html",
      "title": "Getting Started",
      "description": "Your first Shiny app, where to begin?\n",
      "author": [],
      "contents": "\r\n\r\nContents\r\nTemplates\r\nOperating the app\r\nViewer options\r\nRun and Stop\r\n\r\nFile Name\r\n\r\nGetting an app started begins with just a .R file. There are some choices to make in the beginning: a single file app or a multi-page one. It will depend on how you like to organize your code, how much code there will be, and the number of collaborators on the app. For the first part of the session, we will learn with a single file app.\r\nTemplates\r\nYou can write from scratch or you can open a template to get a head start.\r\nClick the drop down on the New File icon  and select Shiny Web App\r\nThe Application Name will be the name of the new directory storing your app file.\r\nSelect Single File\r\nSave it inside the root of your intro-shiny project directory or another place outside of intro-shiny.\r\n\r\nOperating the app\r\nViewer options\r\nBefore you hit Run App  the drop down offers several options for viewing:\r\nRun in Window (RStudio’s pop-up browser)\r\nRun in Viewer Pane\r\nRun External (your default browser)\r\nRun and Stop\r\nAfter clicking Run App, your app will be running locally and your R session will be listening to the localhost. Your console will not respond.\r\nClick on the stop sign icon  to stop your app and resume your R session. If running externally, closing your default browser window does not stop the app.\r\nFile Name\r\nThe file name when using a single file app must be called app.R in order to deploy properly.\r\nFor teaching and learning purposes, the files provided for this module will use a different naming system to show app development at different stages.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-02-18T15:12:17-08:00"
    },
    {
      "path": "index.html",
      "title": "Intro to Shiny",
      "author": [],
      "contents": "\r\nDate: TBDInstructor: Christy LamAssistants: Hana Ševčíková, Craig Helmann, Suzanne Childress, Polina Butrina\r\n\r\n\r\n\r\n\r\nShiny is a package that allows you to easily build interactive web applications. Web development skills aren’t required–all you need is R!\r\nIn this two part module, we’ll walk through how to get started, peek inside the anatomy of a Shiny app, and incorporate packages (from previous modules and introduce some new ones!) to build a polished product.\r\n\r\nSession One\r\nSession Two\r\nGetting Started\r\nMulti-file apps\r\nAnatomy, Inputs & Outputs\r\nPackages\r\nLayout\r\nStyling\r\nReactivity\r\nDeploy\r\n\r\n\r\n\r\n",
      "last_modified": "2021-02-18T15:12:18-08:00"
    },
    {
      "path": "layout.html",
      "title": "Layout",
      "description": "Organize the elements in the UI\n",
      "author": [],
      "contents": "\r\n\r\nContents\r\nPre-defined Layouts\r\nRows and Columns\r\n\r\nWith inputs and outputs established in the UI, we can arrange them with various layout functions.\r\nFor readability, each of the existing UI elements will be set to its own variable in the global section, above ui.\r\n\r\n\r\ntitle <- titlePanel(\"U.S. Baby Names\")\r\nsrc <- p(\"Source:\",\r\n         tags$a(href = \"https://www.ssa.gov/oact/babynames/limits.html\",\r\n                \"Social Security Administration\"))\r\ntxt_box <- textInput(\"name\", \r\n                     label = \"Enter name\",\r\n                     placeholder = \"Jane\")\r\ntxt_disp <- textOutput(\"name_entered\")\r\ntbl_disp <- tableOutput(\"main_table\")\r\n\r\n\r\n\r\nPre-defined Layouts\r\nSome UI functions are pre-set like sidebarLayout().\r\n\r\n\r\nui <- fluidPage(\r\n\r\n  title,\r\n  src,\r\n  \r\n  # A sidebarLayout with sidebarPanel and mainPanel\r\n  sidebarLayout(\r\n    sidebarPanel(),\r\n    mainPanel()\r\n    )\r\n\r\n)\r\n\r\n\r\n\r\nPlace content within sidebarPanel() and mainPanel().\r\n\r\n\r\nui <- fluidPage(\r\n  \r\n  title,\r\n  src,\r\n  \r\n  # A sidebarLayout with sidebarPanel and mainPanel\r\n  sidebarLayout(\r\n    sidebarPanel(\r\n      txt_box,\r\n      txt_disp\r\n    ),\r\n    mainPanel(\r\n      tbl_disp\r\n    )\r\n  )\r\n)\r\n\r\n\r\n\r\nRows and Columns\r\nIn lieu of pre-defined layouts, you can build your layout with rows and columns using fluidRow() or fixedRow(). columns() are created within *Row() .\r\n\r\nSet column widths using an integer between 1 and 12. The maximum number of units within a row is 12.\r\nYou can also embed rows and columns within pre-defined layouts like in the example below.\r\n\r\n\r\nui <- fluidPage(\r\n  \r\n  title,\r\n  src,\r\n  \r\n  # A sidebarLayout with sidebarPanel and mainPanel\r\n  sidebarLayout(\r\n    sidebarPanel(\r\n      txt_box,\r\n      txt_disp\r\n    ),\r\n    mainPanel(\r\n      # create columns within fluidRow or fixedRow \r\n      fluidRow(\r\n        column(\r\n          width = 6,\r\n          h3(\"Table\"),\r\n          tbl_disp\r\n        ),\r\n        column(\r\n          width = 6,\r\n          # add a place holder for a plot\r\n          h3(\"Plot\"),\r\n          plotOutput(\"plot\")\r\n        )\r\n      )\r\n    )\r\n  )\r\n  \r\n)\r\n\r\n\r\n\r\nWhile we’re in the UI, let’s add some additional inputs to the sidebar.\r\n\r\n\r\nui <- fluidPage(\r\n  \r\n  title,\r\n  src,\r\n  \r\n  # sidebar layout with sidebarPanel and mainPanel\r\n  sidebarLayout(\r\n    sidebarPanel(\r\n      txt_box,\r\n      txt_disp,\r\n      # add a dropdown menu to select state\r\n      selectInput(\"state\",\r\n                  label = 'Select State',\r\n                  choices = unique(df$state),\r\n                  selected = 'Washington')\r\n    ),\r\n    mainPanel(\r\n      fluidRow(\r\n        column(\r\n          width = 6,\r\n          h3(\"Table\"),\r\n          tbl_disp\r\n        ),\r\n        column(\r\n          width = 6,\r\n          # add a place holder for a plot\r\n          h3(\"Plot\"),\r\n          plotOutput(\"plot\")\r\n        )\r\n      )\r\n    )\r\n  )\r\n  \r\n)\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2021-02-18T15:12:20-08:00"
    },
    {
      "path": "prework.html",
      "title": "Pre-work",
      "author": [],
      "contents": "\r\n\r\nContents\r\nSession Files on Local Drive\r\nOpen .Rproj\r\n\r\nInstall\r\nTest\r\nOptional\r\nRainbow Parenthesis\r\nMultiple Source columns\r\nshinyapps.io\r\n\r\n\r\nR and the RStudio IDE are required. See the first module on R Basics for guidance.\r\nSession Files on Local Drive\r\nMake sure that the directory of files for the sessions are copied onto your local drive. If they are on PSRC’s network, you may experience extreme sluggishness when using a .Rproj file.\r\nOpen .Rproj\r\nIn the RStudio IDE, open the intro-shiny.Rproj file. Project files will automatically set our working directory–in this case, the root of the intro-shiny directory. No need for setwd() and dealing with file paths!\r\n\r\nAfter opening the .Rproj file, you’ll see some changes to your IDE. Your console and Files pane will reflect the new working directory, and the project name is listed in the top right corner.\r\n To close out of the project, click the project name at the top right corner and select Close Project. On the day of the session, you can access the dropdown in that area of the IDE and select intro-shiny.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nInstall\r\nInstall the following packages by running the following code snippet in the console of your RStudio IDE. Ignore any warnings regarding Rtools and if you are asked to install from sources which needs compilation, click ‘No’.\r\n\r\nSome may have already been installed from previous modules. You can adapt the code snippet accordingly.\r\n\r\n\r\ninstall.packages(c(\"shiny\", \"shinythemes\", \"DT\", \"here\", \"rsconnect\", \r\n                   \"tidyverse\", \"scales\", \"plotly\", \"data.table\", \"sf\", \"leaflet\"))\r\n\r\n\r\n\r\nTest\r\nTest to make sure Shiny works by copying and pasting the code snippet into the console of the RStudio IDE.\r\n\r\n\r\nlibrary(shiny)\r\nif (interactive()) {\r\n  shinyApp(\r\n    ui <- fluidPage(\r\n      selectInput(\"variable\", \"Variable:\",\r\n                  c(\"Cylinders\" = \"cyl\",\r\n                    \"Transmission\" = \"am\",\r\n                    \"Gears\" = \"gear\")),\r\n      tableOutput(\"data\")\r\n    ),\r\n    server <- function(input, output) {\r\n      output$data <- renderTable({\r\n        mtcars[, c(\"mpg\", input$variable), drop = FALSE]\r\n      }, rownames = TRUE)\r\n    }\r\n  )\r\n}\r\n\r\n\r\n\r\nOptional\r\nRainbow Parenthesis\r\n\r\nTurn on rainbow parenthesis. There’ll be a lot of nested parenthesis and brackets so this is a helpful visual tool to keep track of their counterparts.\r\nTools > Global Options > Code > Display \r\n\r\n\r\nThis feature is available in RStudio version 1.4 and above.\r\nMultiple Source columns\r\n\r\nActivate multiple Source columns. When working with a multi-page app, having 2 or more files opened side-by-side might be more ergonomic. After adding additional columns, you can open scripts and drag and drop them in either column.\r\nClick on the pane icon . Pane Layout... > Add Column\r\n\r\n\r\nThis feature is available in RStudio version 1.4 and above.\r\nshinyapps.io\r\n\r\nCreate a free shinyapps.io account. If you want to deploy a project (non-PSRC related and not something with confidential or sensitive data), shinyapps.io is an option.\r\nNote that deleting an account requires you to contact support@rstudio.com.\r\n\r\n\r\nshinyapps.io, an app hosting service by RStudio, offers a free account option, but with limitations.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-02-18T15:12:21-08:00"
    },
    {
      "path": "reactivity.html",
      "title": "Reactivity",
      "author": [],
      "contents": "\r\n\r\nContents\r\nReactive Programming\r\nReactives\r\nObservers\r\nSide-effects\r\n\r\n\r\nDelaying Response\r\neventReactive\r\nobserveEvent\r\n\r\n\r\nReactive Programming\r\nShiny follows a reactive programming paradigm1. We don’t need to command Shiny to update itself, rather, it will react on its own. If an input changes, it will automatically update the outputs dependent upon it.\r\nThink of Shiny as being either energy-saving or lazy (depending on your perspective!). Shiny maximizes the work not done and will only do the most minimal work required to update outputs.\r\nReactives\r\nIn lieu of variables and the typical function that we’d write in a standard R script, R code within the server is often placed inside reactive expressions using reactive({}).\r\n\r\n\r\nserver <- function(input, output) {\r\n  \r\n  # add reactive expression creating a filtered data frame\r\n  filtered_df <- reactive({\r\n    df %>% \r\n      filter(name == input$name & state == input$state)\r\n  })\r\n  \r\n  output$name_entered <- renderText({\r\n    c(\"You entered:\", input$name)\r\n  })\r\n  \r\n  output$main_table <- renderTable({\r\n    # call reactive expression\r\n    filtered_df()\r\n  })\r\n  \r\n  \r\n}\r\n\r\n\r\n\r\nReactives help to not repeat ourselves and break-down complex or lengthy code.\r\nReactives, like standard functions are assigned to a variable and are called upon.\r\nBut unlike the average function, they monitor input and dependencies. If reactive sources change, it will update; otherwise, they are lazy.\r\n\r\n\r\nserver <- function(input, output) {\r\n  \r\n  # add reactive expression to munge name before using in filtered_df()\r\n  clean_name <- reactive({\r\n    input$name %>% \r\n      str_replace_all(\" \", \"\") %>% \r\n      str_trim() %>% \r\n      str_to_title()\r\n  })\r\n  \r\n  # call clean_name() in lieu of input$name\r\n  filtered_df <- reactive({\r\n    df %>% \r\n      filter(name == clean_name() & state == input$state)\r\n  })\r\n  \r\n  output$name_entered <- renderText({\r\n    c(\"You entered:\", input$name)\r\n  })\r\n  \r\n  output$main_table <- renderTable({\r\n    filtered_df()\r\n  })\r\n  \r\n  \r\n}\r\n\r\n\r\n\r\nObservers\r\nIn contrast to the lazy reactive({}), observe({}) is eager and also forgetful — they run as soon as they possibly can and they don’t remember their previous action2.\r\nUnlike reactives, observers:\r\naren’t assigned to a variable\r\naren’t called on\r\ndon’t return values\r\nInstead, observers are used primarily for their side-effects.\r\nSide-effects\r\nSometimes we want our app to perform an action that is beyond our app’s environment. Examples of side-effects can include: writing and saving a file to disk, copying and pasting files, updating a web API, updating a database3, or even updating values of input widgets.\r\nDelaying Response\r\nSpecify when a reaction of a reactive or observer should take place with eventReactive({}) or observeEvent({}). The concept is similar to reactive({}) and observe({}), except they will be driven by an event.\r\neventReactive\r\nThe table might render before we even finish typing a name. To delay that rapid response, we can require that an event take place before the app proceeds with certain tasks.\r\nIn the example below, an action button is created. The event will be when the user clicks on ‘Enter’.\r\n\r\n\r\nui <- fluidPage(\r\n  \r\n  title,\r\n  src,\r\n  \r\n  sidebarLayout(\r\n    sidebarPanel(\r\n      txt_box,\r\n      txt_disp,\r\n      \r\n      selectInput(\"state\",\r\n                  label = 'Select State',\r\n                  choices = unique(df$state),\r\n                  selected = 'Washington'),\r\n      \r\n      # add action button to delay reactivity. Its ID is 'go'.\r\n      actionButton(\"go\", label = \"Enter\")\r\n    ),\r\n    mainPanel(\r\n      fluidRow(\r\n        column(\r\n          width = 6,\r\n          h3(\"Table\"),\r\n          tbl_disp\r\n        ),\r\n        column(\r\n          width = 6,\r\n          h3(\"Plot\"),\r\n          plotOutput(\"plot\")\r\n        )\r\n      )\r\n    )\r\n  )\r\n  \r\n)\r\n\r\n\r\n\r\nFiltering the data frame and other downstream dependencies will begin once the button is clicked.\r\n\r\n\r\nserver <- function(input, output) {\r\n  \r\n  clean_name <- reactive({\r\n    input$name %>% \r\n      str_replace_all(\" \", \"\") %>% \r\n      str_trim() %>% \r\n      str_to_title()\r\n  })\r\n  \r\n  # change reactive to an eventReactive. Delay reaction until action button is clicked\r\n  filtered_df <- eventReactive(input$go, {\r\n    df %>% \r\n      filter(name == clean_name() & state == input$state)\r\n  })\r\n  \r\n  output$name_entered <- renderText({\r\n    c(\"You entered:\", input$name)\r\n  })\r\n  \r\n  output$main_table <- renderTable({\r\n    filtered_df()\r\n  })\r\n\r\n}\r\n\r\n\r\n\r\nobserveEvent\r\nLike observe({}), observeEvent({}) will produce a side-effect; however, it will be triggered only by an event.\r\nA use case of observeEvent is when we want the content of an input widget updated. We can achieve this by nesting an update*() function inside an observeEvent function.\r\nIn the example below, another action button is created. When clicked, it will clear the text inside the text box.\r\n\r\n\r\nui <- fluidPage(\r\n  \r\n  title,\r\n  src,\r\n  \r\n  sidebarLayout(\r\n    sidebarPanel(\r\n      txt_box,\r\n      \r\n      # add a button to clear text input\r\n      actionButton(\"clear\", label = \"Clear Name\"),\r\n      \r\n      txt_disp,\r\n      \r\n      selectInput(\"state\",\r\n                  label = 'Select State',\r\n                  choices = unique(df$state),\r\n                  selected = 'Washington'),\r\n      \r\n      actionButton(\"go\", label = \"Enter\")\r\n    ),\r\n    mainPanel(\r\n      fluidRow(\r\n        column(\r\n          width = 6,\r\n          h3(\"Table\"),\r\n          tbl_disp\r\n        ),\r\n        column(\r\n          width = 6,\r\n          h3(\"Plot\"),\r\n          plotOutput(\"plot\")\r\n        )\r\n      )\r\n    )\r\n  )\r\n  \r\n)\r\n\r\n\r\n\r\nUpdating input controls with update*() functions require a session argument. session like input, and output are inherent in Shiny–it’s not something we need to create, we just need to include it as a parameter to the server function. The session object is an environment that can be used to access information and functionality relating to the session4.\r\n\r\n\r\n# add session argument in the server function\r\nserver <- function(input, output, session) {\r\n  \r\n  clean_name <- reactive({\r\n    input$name %>% \r\n      str_replace_all(\" \", \"\") %>% \r\n      str_trim() %>% \r\n      str_to_title()\r\n  })\r\n  \r\n  # using an observeEvent, update the textInput by clearing the typed name when the \r\n  # 'Clear Name' button is clicked\r\n  observeEvent(input$clear, {\r\n    updateTextInput(session, \r\n                    \"name\",\r\n                    value = \"\"\r\n    )\r\n  })\r\n \r\n  filtered_df <- eventReactive(input$go, {\r\n    df %>% \r\n      filter(name == clean_name() & state == input$state)\r\n  })\r\n  \r\n  output$name_entered <- renderText({\r\n    c(\"You entered:\", input$name)\r\n  })\r\n  \r\n  output$main_table <- renderTable({\r\n    filtered_df()\r\n  })\r\n\r\n}\r\n\r\n\r\n\r\n\r\nhttps://mastering-shiny.org/basic-reactivity.html#reactive-programming↩︎\r\nhttps://mastering-shiny.org/reactivity-objects.html#observers-details↩︎\r\nhttps://mastering-shiny.org/basic-reactivity.html#observers↩︎\r\nhttps://shiny.rstudio.com/reference/shiny/latest/session.html↩︎\r\n",
      "last_modified": "2021-02-18T15:12:24-08:00"
    },
    {
      "path": "resources.html",
      "title": "Resources",
      "description": "An opinionated list of guides or tutorials for Shiny and helping packages\n",
      "author": [],
      "contents": "\r\n\r\nContents\r\nShiny\r\nVisualization Packages\r\nDT\r\nOther htmlwidgets\r\n\r\nReactable\r\n\r\n\r\nShiny\r\nShiny Gallery’s Shiny Demo: interactive examples of various Shiny features (individual widgets, layout styles, and reactivity). The source code is displayed as you interact with the examples. It’s a great way to learn!\r\nOfficial Cheatsheet: A two-pager of Shiny utilities.\r\nMastering Shiny Book: A book (in progress) by Hadley Wickham. See the Getting Started section. For those who use the tidyverse, it also includes a section on the latest version of tidy evaluation–essential for programming with packages like dplyr or ggplot2.\r\nVisualization Packages\r\nDT\r\nOther htmlwidgets\r\nReactable\r\nAnother interactive table package. On the surface, basic use of reactable might not be that different than DT, but the ability to create expandable rows and nested tables, and the conditional styling examples really makes this package stand out.\r\nTo see a Shiny app with a reactable table in the wild, see this reactable example, code is available here.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-02-18T15:12:25-08:00"
    }
  ],
  "collections": []
}
