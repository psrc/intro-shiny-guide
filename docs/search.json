{
  "articles": [
    {
      "path": "anatomy.html",
      "title": "Shiny Anatomy",
      "description": "The guts and connective tissue\n",
      "author": [],
      "contents": "\r\n\r\nContents\r\nGlobal\r\nUI & Server\r\nOutputs & Render\r\nInputs\r\n\r\n\r\nStart with file: intro-shiny/babynames/00-anatomy/app-baby-00.R\r\nA Shiny app generally consists of three parts: the user interface (UI), the server, and a place for global variables.\r\nGlobal\r\nIn a single file app, packages and global variables can be loaded at the top of the script.\r\n\r\n\r\nlibrary(shiny)\r\nlibrary(tidyverse)\r\nlibrary(here)\r\n\r\ndf <- read_csv(here('data', 'babynames.csv'))\r\n\r\n\r\n\r\nUI & Server\r\nThe UI is comprised of R functions that will ultimately generate HTML–a markup language that structures and presents content for the web.\r\n\r\n\r\nui <- fluidPage(\r\n  \r\n  # static elements in the UI\r\n  titlePanel(\"U.S. Baby Names\"),\r\n  p(\"Source:\", \r\n    tags$a(href = \"https://www.ssa.gov/oact/babynames/limits.html\", \r\n           \"Social Security Administration\"))\r\n)\r\n\r\n\r\n\r\nStore elements of your UI inside fluidPage() separated by commas. You can use any of the following methods to build the UI:\r\nShiny UI functions (e.g. titlePanel())\r\nReference HTML tags using tag$ as a prefix (e.g tag$img()).\r\nFor a list of HTML tags: names(tags)\r\nThe most common tags are functions themselves and don’t require the prefix (e.g. p(), h1(), etc.)\r\n\r\nraw HTML within the wrapper html()\r\nOutputs & Render\r\nFunctions ending in *Output(), creates space(s) in the UI for R outputs, such as tables and plots. However, the UI can’t process and display R output by itself. It requires help from the server.\r\n\r\n\r\nui <- fluidPage(\r\n  \r\n  titlePanel(\"U.S. Baby Names\"),\r\n  p(\"Source:\", \r\n    tags$a(href = \"https://www.ssa.gov/oact/babynames/limits.html\", \r\n           \"Social Security Administration\")),\r\n  \r\n  # a place to display our data frame as a table. Its ID is 'main_table'\r\n  tableOutput(\"main_table\")\r\n  \r\n)\r\n\r\n\r\n\r\nFor every *Output() there must be a compatible render*() in the server. They work as pairs, connected by the unique name of the output, to add R output to the UI.\r\n\r\n\r\nserver <- function(input, output) {\r\n  \r\n  # render the r object `df` to the space called, 'main_table'.\r\n  output$main_table <- renderTable({\r\n    df %>% slice(1:20)\r\n    })\r\n}\r\n\r\n\r\n\r\nThe server is one large function that passes in inputs and outputs (and depending on what you’re doing, a session argument). output is inherent in Shiny–it is a list-like object referencing the outputs in the UI and additional code required to update each output object1.\r\nInputs\r\nWhat makes Shiny interactive are inputs. Input widgets such as text boxes, checkboxes, dropdown menus, buttons, and many others, collect values from the user.\r\nSimilar to *Output(), inputs also require a unique name. The unique inputID is what connects the front-end to the back-end.\r\n\r\n\r\nui <- fluidPage(\r\n  \r\n    titlePanel(\"U.S. Baby Names\"),\r\n    p(\"Source:\", \r\n      tags$a(href = \"https://www.ssa.gov/oact/babynames/limits.html\", \r\n             \"Social Security Administration\")),\r\n    \r\n    # A text box to enter a name. Its ID is 'name'.\r\n    textInput(\"name\", \r\n              label = \"Enter name\",\r\n              placeholder = \"Jane\"),\r\n    \r\n    tableOutput(\"main_table\")\r\n  \r\n)\r\n\r\n\r\n\r\nIn this example, we collect the user’s input value from textInput() and display it in the output area called name_entered.\r\n\r\n\r\nui <- fluidPage(\r\n  \r\n    titlePanel(\"U.S. Baby Names\"),\r\n    p(\"Source:\", \r\n      tags$a(href = \"https://www.ssa.gov/oact/babynames/limits.html\", \r\n             \"Social Security Administration\")),\r\n    \r\n    textInput(\"name\", \r\n              label = \"Enter name\",\r\n              placeholder = \"Jane\"),\r\n    \r\n    # Display the name that was entered in textInput\r\n    textOutput(\"name_entered\"),\r\n    \r\n    tableOutput(\"main_table\")\r\n  \r\n)\r\n\r\n\r\n\r\nServer-side, reference the input value with input$ as a prefix and the unique name of the input widget. input like output is inherent to Shiny. It is a list-like object containing all inputIDs from the UI.\r\n\r\n\r\nserver <- function(input, output) {\r\n  \r\n  # render the textInput to the designated output\r\n  output$name_entered <- renderText({\r\n    c(\"You entered:\", input$name)\r\n  })\r\n  \r\n  output$main_table <- renderTable({\r\n    df %>% slice(1:20)\r\n    })\r\n  \r\n   \r\n}\r\n\r\n\r\n\r\n\r\nhttps://shiny.rstudio.com/tutorial/written-tutorial/lesson4/↩︎\r\n",
      "last_modified": "2021-03-16T20:59:57-07:00"
    },
    {
      "path": "getting_started.html",
      "title": "Getting Started",
      "description": "Your first Shiny app, where to begin?\n",
      "author": [],
      "contents": "\r\n\r\nContents\r\nTemplates\r\nOperating the app\r\nViewer options\r\nRun and Stop\r\n\r\nFile Name\r\n\r\nGetting an app started begins with just a .R file. There are some choices to make in the beginning: a single file app or a multi-page one. It will depend on how you like to organize your code, how much code there will be, and the number of collaborators on the app. For the first part of the session, we will learn with a single file app.\r\nTemplates\r\nYou can write from scratch or you can open a template to get a head start.\r\nClick the drop down on the New File icon  and select Shiny Web App\r\nThe Application Name will be the name of the new directory storing your app file.\r\nSelect Single File\r\nSave it inside the root of your intro-shiny project directory or another place outside of intro-shiny.\r\n\r\nOperating the app\r\nViewer options\r\nBefore you hit Run App  the drop down offers several options for viewing:\r\nRun in Window (RStudio’s pop-up browser)\r\nRun in Viewer Pane\r\nRun External (your default browser)\r\nRun and Stop\r\nAfter clicking Run App, your app will be running locally and your R session will be listening to the localhost. Your console will not respond.\r\nClick on the stop sign icon  to stop your app and resume your R session. If running externally, closing your default browser window does not stop the app.\r\nFile Name\r\nThe file name when using a single file app must be called app.R in order to deploy properly.\r\nFor teaching and learning purposes, the files provided for this module will use a different naming system to show app development at different stages.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-03-16T20:59:58-07:00"
    },
    {
      "path": "index.html",
      "title": "Intro to Shiny",
      "author": [],
      "contents": "\r\nDate: TBDInstructor: Christy LamAssistants: Hana Ševčíková, Craig Helmann, Suzanne Childress, Polina Butrina\r\n\r\n\r\n\r\n\r\nShiny is a package that allows you to easily build interactive web applications. Web development skills aren’t required–all you need is R!\r\nIn this two part module, we’ll walk through how to get started, peek inside the anatomy of a Shiny app, and incorporate packages (from previous modules and introduce some new ones!) to build a polished product.\r\n\r\nSession One\r\nSession Two\r\nGetting Started\r\nPackages II\r\nAnatomy, Inputs & Outputs\r\nStyling\r\nLayout\r\nMulti-file apps\r\nReactivity\r\nDeploy\r\nPackages I\r\nShiny Cousins and Friends\r\n\r\n\r\n\r\n",
      "last_modified": "2021-03-16T20:59:59-07:00"
    },
    {
      "path": "layout.html",
      "title": "Layout",
      "description": "Organize the elements in the UI\n",
      "author": [],
      "contents": "\r\n\r\nContents\r\nPre-defined Layouts\r\nRows and Columns\r\n\r\nStart with a new file: intro-shiny/babynames/01-layout/app-baby-01.R\r\nWith inputs and outputs established in the UI, we can arrange them with various layout functions.\r\nFor readability, each of the existing UI elements will be set to its own variable in the global section, above ui.\r\n\r\n\r\ntitle <- titlePanel(\"U.S. Baby Names\")\r\nsrc <- p(\"Source:\",\r\n         tags$a(href = \"https://www.ssa.gov/oact/babynames/limits.html\",\r\n                \"Social Security Administration\"))\r\ntxt_box <- textInput(\"name\", \r\n                     label = \"Enter name\",\r\n                     placeholder = \"Jane\")\r\ntxt_disp <- textOutput(\"name_entered\")\r\ntbl_disp <- tableOutput(\"main_table\")\r\n\r\n\r\n\r\nPre-defined Layouts\r\nSome UI functions are pre-set like sidebarLayout().\r\n\r\n\r\nui <- fluidPage(\r\n\r\n  title,\r\n  src,\r\n  \r\n  # A sidebarLayout with sidebarPanel and mainPanel\r\n  sidebarLayout(\r\n    sidebarPanel(),\r\n    mainPanel()\r\n    )\r\n\r\n)\r\n\r\n\r\n\r\nPlace content within sidebarPanel() and mainPanel().\r\n\r\n\r\nui <- fluidPage(\r\n  \r\n  title,\r\n  src,\r\n  \r\n  # A sidebarLayout with sidebarPanel and mainPanel\r\n  sidebarLayout(\r\n    sidebarPanel(\r\n      txt_box,\r\n      txt_disp\r\n    ),\r\n    mainPanel(\r\n      tbl_disp\r\n    )\r\n  )\r\n)\r\n\r\n\r\n\r\nRows and Columns\r\nIn lieu of pre-defined layouts, you can build your layout with rows and columns using fluidRow() or fixedRow(). columns() are created within *Row() .\r\n\r\nSet column widths using an integer between 1 and 12. The maximum number of units within a row is 12.\r\nYou can also embed rows and columns within pre-defined layouts like in the example below.\r\n\r\n\r\nui <- fluidPage(\r\n  \r\n  title,\r\n  src,\r\n  \r\n  # A sidebarLayout with sidebarPanel and mainPanel\r\n  sidebarLayout(\r\n    sidebarPanel(\r\n      txt_box,\r\n      txt_disp\r\n    ),\r\n    mainPanel(\r\n      # create columns within fluidRow or fixedRow \r\n      fluidRow(\r\n        column(\r\n          width = 6,\r\n          h3(\"Table\"),\r\n          tbl_disp\r\n        ),\r\n        column(\r\n          width = 6,\r\n          # add a place holder for a plot\r\n          h3(\"Plot\"),\r\n          plotOutput(\"plot\")\r\n        )\r\n      )\r\n    )\r\n  )\r\n  \r\n)\r\n\r\n\r\n\r\nWhile we’re in the UI, let’s add some additional inputs to the sidebar.\r\n\r\n\r\nui <- fluidPage(\r\n  \r\n  title,\r\n  src,\r\n  \r\n  # sidebar layout with sidebarPanel and mainPanel\r\n  sidebarLayout(\r\n    sidebarPanel(\r\n      txt_box,\r\n      txt_disp,\r\n      # add a dropdown menu to select state\r\n      selectInput(\"state\",\r\n                  label = 'Select State',\r\n                  choices = unique(df$state),\r\n                  selected = 'Washington')\r\n    ),\r\n    mainPanel(\r\n      fluidRow(\r\n        column(\r\n          width = 6,\r\n          h3(\"Table\"),\r\n          tbl_disp\r\n        ),\r\n        column(\r\n          width = 6,\r\n          # add a place holder for a plot\r\n          h3(\"Plot\"),\r\n          plotOutput(\"plot\")\r\n        )\r\n      )\r\n    )\r\n  )\r\n  \r\n)\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2021-03-16T21:00:01-07:00"
    },
    {
      "path": "packages_i.html",
      "title": "Packages I",
      "description": "dplyr and plots with ggplot2 & Plotly\n",
      "author": [],
      "contents": "\r\n\r\nContents\r\nPlots\r\nggplot2\r\nPlotly\r\n\r\nTidy Evaluation\r\n\r\nShiny provides the basic tools for client-server interaction, but a lot of parts that make up an app–how it wrangles and displays data, can come from packages of your choice. All of the packages introduced in the R Learning Series so far (dplyr, ggplot2, plotly, data.table, R markdown, sf, leaflet) can be included in Shiny.\r\nPlots\r\nggplot2 can be used with the standard plotOutput() and renderPlot({}) functions.\r\nggplot2\r\n\r\n\r\n# Server\r\n\r\n  output$plot <- renderPlot({\r\n    filtered_df() %>% \r\n      ggplot(aes(x = year, y = count, color = state)) +\r\n        geom_line() +\r\n        facet_wrap(vars(sex), nrow = 2, scales = \"free_y\")\r\n  })\r\n\r\n\r\n\r\nTo add more content to our plot (and table), enable the dropdown menu to allow the user to select multiple states.\r\n\r\n\r\n# UI \r\n\r\n  # add multiple argument to allow more than one selection\r\n  selectInput(\"state\",\r\n              label = 'Select State',\r\n              choices = unique(df$state),\r\n              selected = 'Washington',\r\n              multiple = TRUE)\r\n\r\n\r\n\r\n\r\n\r\n# Server\r\n\r\n # allow filtering of multiple states with `%in%`\r\n  filtered_df <- eventReactive(input$go, {\r\n    df %>% \r\n      filter(name == clean_name() & state %in% input$state)\r\n  })\r\n\r\n\r\n\r\nPlotly\r\nPlotly, a package that helps create interactive graphs, can be used to convert a static ggplot2 graph into an interactive one. Plotly on its own can also be used in lieu of ggplot2.\r\nTo render Plotly graphs in Shiny, use plotlyOutput() and renderPlotly({}) in lieu of the standard plot output and render functions.\r\nInclude the plotly package in the global section.\r\n\r\n\r\nlibrary(plotly)\r\n\r\n\r\n\r\nConvert existing plot output and render functions to their respective Plotly equivalent.\r\n\r\n\r\n# UI\r\n\r\n  # convert plotOutput to a Plotly Output\r\n  plotlyOutput(\"plot\")\r\n\r\n\r\n\r\n\r\n\r\n# Server\r\n  \r\n  # convert renderPlot to renderPlotly\r\n  output$plot <- renderPlotly({\r\n    \r\n    # create ggplot object\r\n    p <- filtered_df() %>% \r\n      ggplot(aes(x = year, y = count, color = state)) +\r\n        geom_line() +\r\n        facet_wrap(vars(sex), nrow = 2, scales = \"free_y\")\r\n    \r\n    # wrap ggplot object with ggplotly\r\n    ggplotly(p)\r\n  })\r\n\r\n\r\n\r\nTidy Evaluation\r\nTypically in dplyr functions, data-variables (a.k.a column names) are entered directly in the function without any extra syntax ($ or quotation marks). Data-variables mapped in ggplot2’s aes() also follow the same concept.\r\ndf %>% arrange(count)\r\nggplot(df, aes(x = year, y = count))\r\nHowever when the data-variable (e.g. count) is stored in a variable (e.g. my_column <- 'count'), or as part of another object (e.g. input$my_input_widget), additional syntax is required to accommodate this indirection.\r\nfor single data-variables: .data[[ <insert data-variable> ]]\r\nfor multiple data-variables in dplyr: across(all_of( <insert data-variable> ))\r\nLet’s add a dropdown menu that allows the user to choose which column to sort the table by.\r\n\r\n\r\nui <- fluidPage(\r\n  \r\n  title,\r\n  src,\r\n  \r\n  sidebarLayout(\r\n    sidebarPanel(\r\n      txt_box,\r\n      actionButton(\"clear\", label = \"Clear Name\"),\r\n      txt_disp,\r\n      selectInput(\"state\",\r\n                  label = 'Select State',\r\n                  choices = unique(df$state),\r\n                  selected = 'Washington',\r\n                  multiple = TRUE),\r\n      \r\n      # add dropdowns for user to decide how table is sorted \r\n      selectInput('table_sort',\r\n                  label = 'Sort table by',\r\n                  choices = c('count', 'sex', 'year')),\r\n      \r\n      actionButton(\"go\", label = \"Enter\")\r\n    ),\r\n    mainPanel(\r\n      fluidRow(\r\n        column(\r\n          width = 6,\r\n          h3(\"Table\"),\r\n          tbl_disp\r\n        ),\r\n        column(\r\n          width = 6,\r\n          h3(\"Plot\"),\r\n          plotlyOutput(\"plot\")\r\n        )\r\n      )\r\n    )\r\n  )\r\n  \r\n)\r\n\r\n\r\n\r\nIn the server, apply the .data[[]] wrapper inside arrange().\r\n\r\n\r\n# Server\r\n\r\n  filtered_df <- eventReactive(input$go, {\r\n    df %>%\r\n      filter(name == clean_name() & state %in% input$state) %>% \r\n      arrange(.data[[input$table_sort]]) # add arrange, pass input value using tidy evaluation syntax\r\n  })\r\n\r\n\r\n\r\nIf there are multiple values selected by the user for an input and applied in dplyr, wrap the reactive source within across(all_of()).\r\n\r\n\r\n# UI\r\n\r\n# add dropdowns for user to decide how table is sorted \r\nselectInput('table_sort',\r\n            label = 'Sort table by',\r\n            choices = c('count', 'sex', 'year'),\r\n            multiple = TRUE) # allow more than one selection\r\n\r\n\r\n\r\n\r\n\r\n# Server\r\n\r\n  filtered_df <- eventReactive(input$go, {\r\n    df %>%\r\n      filter(name == clean_name() & state %in% input$state) %>% \r\n      arrange(across(all_of(input$table_sort))) # add arrange, pass input value using tidy evaluation syntax\r\n  })\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2021-03-16T21:00:05-07:00"
    },
    {
      "path": "packages_ii.html",
      "title": "Packages II",
      "description": "Interactive tables with DT\n",
      "author": [],
      "contents": "\r\n\r\nContents\r\nDT\r\nOptions\r\nHide Columns\r\n\r\nFormat & Styling\r\n\r\nReactable\r\n\r\nStart with a new file: intro-shiny/babynames/04-packages-02/app-baby-04.R\r\nAllow users to sort or filter your tables without having to expand the UI. Simply use packages such as DT or Reactable to present data frames as interactive tables.\r\nDT\r\nDT stands for data table (not to be confused with the wrangling/processing package data.table). Like, Plotly, DT is part of the htmlwidgets family. Developers have taken the JavaScript version of DT and bound it with R. We don’t have to learn JS in order to experience its benefits!\r\n\r\n\r\n# Load package\r\nlibrary(DT)\r\n\r\n\r\n\r\nChange the output and render function names.\r\n\r\n\r\n# UI\r\n\r\n# in lieu of tableOutput(), use DT's version\r\ntbl_disp <- DTOutput(\"main_table\")\r\n\r\n\r\n\r\n\r\n\r\n# Server\r\n\r\n  # in lieu of renderTable(), use DT's version\r\n  output$main_table <- renderDT({\r\n    filtered_df()\r\n  })\r\n\r\n\r\n\r\nOptions\r\nDT offers options to customize the appearance of your table without manipulating the data itself.\r\n\r\n\r\n# Server\r\n\r\n  output$main_table <- renderDT({\r\n    df <- filtered_df()\r\n    \r\n    # customize the appearance of the DT\r\n    datatable(df,\r\n              rownames = FALSE,\r\n              colnames = str_to_title(str_replace_all(colnames(df), \"_\", \" \")),\r\n              options = list(pageLength = 20,\r\n                             lengthMenu = c(20, 60, 100),\r\n                             dom = 'ltipr' # default is 'lftipr', exclude f to remove search bar \r\n                             ),\r\n              filter = 'top'\r\n              )\r\n   \r\n  })\r\n\r\n\r\n\r\nBy default DT includes some table control elements such as page length, pagination, and the filter (search) bar. Toggle these elements with the dom keyword argument. The dom options and their definitions can be found here: https://datatables.net/reference/option/dom\r\nHide Columns\r\n\r\n\r\n# Server\r\n\r\n  output$main_table <- renderDT({\r\n    \r\n    # remove the last three columns\r\n    df <- filtered_df()[, 1:(ncol(df)-3)]\r\n    \r\n    datatable(df,\r\n              rownames = FALSE,\r\n              colnames = str_to_title(str_replace_all(colnames(df), \"_\", \" \")),\r\n              options = list(pageLength = 20,\r\n                             lengthMenu = c(20, 60, 100),\r\n                             dom = 'ltipr' # default is 'lftipr', exclude f to remove search bar \r\n                             ),\r\n              filter = 'top'\r\n              )\r\n   \r\n  })\r\n\r\n\r\n\r\nIn the previous example, to remove the last three columns from the table we manipulated the data frame itself. In lieu of altering the data, it’s possible to use DT to simply hide the columns by using the columnDefs argument within options. There are, however, several quirks to know!\r\nThe targets argument require a numeric vector. Column names don’t work.\r\nThe first column in the DT is 0 not 1.\r\n\r\n\r\n# hiding the last 3 columns in an 8 column table.\r\ndatatable(...,\r\n          options = list(columnDefs = list(list(visible = FALSE, targets = c(5, 6, 7))))\r\n          )\r\n\r\n\r\n\r\nFormat & Styling\r\nFormat and style the table with some helper functions. Without manipulating the data itself, table columns can be displayed as currency, percentages, round numbers, or dates.\r\nformatCurrency()\r\nformatPercentage()\r\nformatRound()\r\nformatDate()\r\nAdditionally, styles can also be applied to table cells with a few helping functions:\r\nstyleInterval(): style for intervals of data.\r\nstyleColorBar(): displaying a color bar in the cell. Its size is relative to the share of the largest value in the column.\r\nstyleEqual(): style based on unique values.\r\n\r\n\r\n# Server\r\n\r\n   output$main_table <- renderDT({\r\n    \r\n    # remove last three columns\r\n    df <- filtered_df()[, 1:(ncol(df)-3)]\r\n    \r\n    # customize the appearance of the DT\r\n    datatable(df,\r\n              rownames = FALSE,\r\n              colnames = str_to_title(str_replace_all(colnames(df), \"_\", \" \")),\r\n              options = list(pageLength = 20,\r\n                             lengthMenu = c(20, 60, 100),\r\n                             dom = 'ltipr' # default is 'lftipr'\r\n                             ),\r\n              filter = 'top'\r\n              ) %>%\r\n      \r\n      # conditional styling of cell text\r\n      formatStyle('name',\r\n                  'sex',\r\n                  color = styleEqual(unique(df$sex), c('dodgerblue', 'orange'))\r\n      ) %>% \r\n      \r\n      # add a color bar to a numeric column.\r\n      formatStyle('count',\r\n                  background = styleColorBar(df$count, 'rgba(0, 128, 255, .2)'),\r\n                  backgroundSize = '100% 90%',\r\n                  backgroundRepeat = 'no-repeat',\r\n                  backgroundPosition = 'center'\r\n                  )\r\n    \r\n  })\r\n\r\n\r\n\r\nKeyword arguments in formatStyle() are simply CSS properties. Properties are written in camel case (backgroundSize) instead of kebab case (background-size).\r\nReactable\r\nReactable is a more recent interactive data table package. It is similar to DT but also includes additional features such as:\r\nembedding htmlwidgets (e.g. sparklines, boxplots, etc.) within cells.\r\nother custom rendering\r\ncustom grouping and aggregation\r\nexpandable row details\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "last_modified": "2021-03-16T21:00:07-07:00"
    },
    {
      "path": "prework.html",
      "title": "Pre-work",
      "author": [],
      "contents": "\r\n\r\nContents\r\nSession Files on Local Drive\r\nOpen .Rproj\r\n\r\nInstall\r\nTest\r\nOptional\r\nRainbow Parenthesis\r\nMultiple Source columns\r\nshinyapps.io\r\n\r\n\r\nR and the RStudio IDE are required. See the first module on R Basics for guidance.\r\nSession Files on Local Drive\r\nMake sure that the directory of files for the sessions are copied onto your local drive. If they are on PSRC’s network, you may experience extreme sluggishness when using a .Rproj file.\r\nOpen .Rproj\r\nIn the RStudio IDE, open the intro-shiny.Rproj file. Project files will automatically set our working directory–in this case, the root of the intro-shiny directory. No need for setwd() and dealing with file paths!\r\n\r\nAfter opening the .Rproj file, you’ll see some changes to your IDE. Your console and Files pane will reflect the new working directory, and the project name is listed in the top right corner.\r\n To close out of the project, click the project name at the top right corner and select Close Project. On the day of the session, you can access the dropdown in that area of the IDE and select intro-shiny.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nInstall\r\nInstall the following packages by running the following code snippet in the console of your RStudio IDE. Ignore any warnings regarding Rtools and if you are asked to install from sources which needs compilation, click ‘No’.\r\n\r\nSome may have already been installed from previous modules. You can adapt the code snippet accordingly.\r\n\r\n\r\ninstall.packages(c(\"shiny\", \"shinythemes\", \"DT\", \"here\", \"rsconnect\", \r\n                   \"tidyverse\", \"scales\", \"plotly\", \"data.table\", \"sf\", \"leaflet\"))\r\n\r\n\r\n\r\nTest\r\nTest to make sure Shiny works by copying and pasting the code snippet into the console of the RStudio IDE.\r\n\r\n\r\nlibrary(shiny)\r\nif (interactive()) {\r\n  shinyApp(\r\n    ui <- fluidPage(\r\n      selectInput(\"variable\", \"Variable:\",\r\n                  c(\"Cylinders\" = \"cyl\",\r\n                    \"Transmission\" = \"am\",\r\n                    \"Gears\" = \"gear\")),\r\n      tableOutput(\"data\")\r\n    ),\r\n    server <- function(input, output) {\r\n      output$data <- renderTable({\r\n        mtcars[, c(\"mpg\", input$variable), drop = FALSE]\r\n      }, rownames = TRUE)\r\n    }\r\n  )\r\n}\r\n\r\n\r\n\r\nOptional\r\nRainbow Parenthesis\r\n\r\nTurn on rainbow parenthesis. There’ll be a lot of nested parenthesis and brackets so this is a helpful visual tool to keep track of their counterparts.\r\nTools > Global Options > Code > Display \r\n\r\n\r\nThis feature is available in RStudio version 1.4 and above.\r\nMultiple Source columns\r\n\r\nActivate multiple Source columns. When working with a multi-page app, having 2 or more files opened side-by-side might be more ergonomic. After adding additional columns, you can open scripts and drag and drop them in either column.\r\nClick on the pane icon . Pane Layout... > Add Column\r\n\r\n\r\nThis feature is available in RStudio version 1.4 and above.\r\nshinyapps.io\r\n\r\nCreate a free shinyapps.io account. If you want to deploy a project (non-PSRC related and not something with confidential or sensitive data), shinyapps.io is an option.\r\nNote that deleting an account requires you to contact support@rstudio.com.\r\n\r\n\r\nshinyapps.io, an app hosting service by RStudio, offers a free account option, but with limitations.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-03-16T21:00:08-07:00"
    },
    {
      "path": "reactivity.html",
      "title": "Reactivity",
      "author": [],
      "contents": "\r\n\r\nContents\r\nReactive Programming\r\nReactives\r\nObservers\r\nSide-effects\r\n\r\n\r\nDelaying Response\r\neventReactive\r\nobserveEvent\r\n\r\n\r\nReactive Programming\r\nShiny follows a reactive programming paradigm1. We don’t need to command Shiny to update itself, rather, it will react on its own. If an input changes, it will automatically update the outputs dependent upon it.\r\nThink of Shiny as being either energy-saving or lazy (depending on your perspective!). Shiny maximizes the work not done and will only do the most minimal work required to update outputs.\r\nReactives\r\nIn lieu of variables and the typical function that we’d write in a standard R script, R code within the server is often placed inside reactive expressions using reactive({}).\r\n\r\n\r\nserver <- function(input, output) {\r\n  \r\n  # add reactive expression creating a filtered data frame\r\n  filtered_df <- reactive({\r\n    df %>% \r\n      filter(name == input$name & state == input$state)\r\n  })\r\n  \r\n  output$name_entered <- renderText({\r\n    c(\"You entered:\", input$name)\r\n  })\r\n  \r\n  output$main_table <- renderTable({\r\n    # call reactive expression\r\n    filtered_df()\r\n  })\r\n  \r\n  \r\n}\r\n\r\n\r\n\r\nReactives help to not repeat ourselves and break-down complex or lengthy code.\r\nReactives, like standard functions are assigned to a variable and are called upon.\r\nBut unlike the average function, they monitor input and dependencies. If reactive sources change, it will update; otherwise, they are lazy.\r\n\r\n\r\nserver <- function(input, output) {\r\n  \r\n  # add reactive expression to munge name before using in filtered_df()\r\n  clean_name <- reactive({\r\n    input$name %>% \r\n      str_replace_all(\" \", \"\") %>% \r\n      str_trim() %>% \r\n      str_to_title()\r\n  })\r\n  \r\n  # call clean_name() in lieu of input$name\r\n  filtered_df <- reactive({\r\n    df %>% \r\n      filter(name == clean_name() & state == input$state)\r\n  })\r\n  \r\n  output$name_entered <- renderText({\r\n    c(\"You entered:\", input$name)\r\n  })\r\n  \r\n  output$main_table <- renderTable({\r\n    filtered_df()\r\n  })\r\n  \r\n  \r\n}\r\n\r\n\r\n\r\nObservers\r\nIn contrast to the lazy reactive({}), observe({}) is eager and also forgetful — they run as soon as they possibly can and they don’t remember their previous action2.\r\nUnlike reactives, observers:\r\naren’t assigned to a variable\r\naren’t called on\r\ndon’t return values\r\nInstead, observers are used primarily for their side-effects.\r\nSide-effects\r\nSometimes we want our app to perform an action that is beyond our app’s environment. Examples of side-effects can include: writing and saving a file to disk, copying and pasting files, updating a web API, updating a database3, or even updating values of input widgets.\r\nDelaying Response\r\nSpecify when a reaction of a reactive or observer should take place with eventReactive({}) or observeEvent({}). The concept is similar to reactive({}) and observe({}), except they will be driven by an event.\r\neventReactive\r\nThe table might render before we even finish typing a name. To delay that rapid response, we can require that an event take place before the app proceeds with certain tasks.\r\nIn the example below, an action button is created. The event will be when the user clicks on ‘Enter’.\r\n\r\n\r\nui <- fluidPage(\r\n  \r\n  title,\r\n  src,\r\n  \r\n  sidebarLayout(\r\n    sidebarPanel(\r\n      txt_box,\r\n      txt_disp,\r\n      \r\n      selectInput(\"state\",\r\n                  label = 'Select State',\r\n                  choices = unique(df$state),\r\n                  selected = 'Washington'),\r\n      \r\n      # add action button to delay reactivity. Its ID is 'go'.\r\n      actionButton(\"go\", label = \"Enter\")\r\n    ),\r\n    mainPanel(\r\n      fluidRow(\r\n        column(\r\n          width = 6,\r\n          h3(\"Table\"),\r\n          tbl_disp\r\n        ),\r\n        column(\r\n          width = 6,\r\n          h3(\"Plot\"),\r\n          plotOutput(\"plot\")\r\n        )\r\n      )\r\n    )\r\n  )\r\n  \r\n)\r\n\r\n\r\n\r\nFiltering the data frame and other downstream dependencies will begin once the button is clicked.\r\n\r\n\r\nserver <- function(input, output) {\r\n  \r\n  clean_name <- reactive({\r\n    input$name %>% \r\n      str_replace_all(\" \", \"\") %>% \r\n      str_trim() %>% \r\n      str_to_title()\r\n  })\r\n  \r\n  # change reactive to an eventReactive. Delay reaction until action button is clicked\r\n  filtered_df <- eventReactive(input$go, {\r\n    df %>% \r\n      filter(name == clean_name() & state == input$state)\r\n  })\r\n  \r\n  output$name_entered <- renderText({\r\n    c(\"You entered:\", input$name)\r\n  })\r\n  \r\n  output$main_table <- renderTable({\r\n    filtered_df()\r\n  })\r\n\r\n}\r\n\r\n\r\n\r\nobserveEvent\r\nLike observe({}), observeEvent({}) will produce a side-effect; however, it will be triggered only by an event.\r\nA use case of observeEvent is when we want the content of an input widget updated. We can achieve this by nesting an update*() function inside an observeEvent function.\r\nIn the example below, another action button is created. When clicked, it will clear the text inside the text box.\r\n\r\n\r\nui <- fluidPage(\r\n  \r\n  title,\r\n  src,\r\n  \r\n  sidebarLayout(\r\n    sidebarPanel(\r\n      txt_box,\r\n      \r\n      # add a button to clear text input\r\n      actionButton(\"clear\", label = \"Clear Name\"),\r\n      \r\n      txt_disp,\r\n      \r\n      selectInput(\"state\",\r\n                  label = 'Select State',\r\n                  choices = unique(df$state),\r\n                  selected = 'Washington'),\r\n      \r\n      actionButton(\"go\", label = \"Enter\")\r\n    ),\r\n    mainPanel(\r\n      fluidRow(\r\n        column(\r\n          width = 6,\r\n          h3(\"Table\"),\r\n          tbl_disp\r\n        ),\r\n        column(\r\n          width = 6,\r\n          h3(\"Plot\"),\r\n          plotOutput(\"plot\")\r\n        )\r\n      )\r\n    )\r\n  )\r\n  \r\n)\r\n\r\n\r\n\r\nUpdating input controls with update*() functions require a session argument. session like input, and output are inherent in Shiny–it’s not something we need to create, we just need to include it as a parameter to the server function. The session object is an environment that can be used to access information and functionality relating to the session4.\r\n\r\n\r\n# add session parameter in the server function\r\nserver <- function(input, output, session) {\r\n  \r\n  clean_name <- reactive({\r\n    input$name %>% \r\n      str_replace_all(\" \", \"\") %>% \r\n      str_trim() %>% \r\n      str_to_title()\r\n  })\r\n  \r\n  # using an observeEvent, update the textInput by clearing the typed name when the \r\n  # 'Clear Name' button is clicked\r\n  observeEvent(input$clear, {\r\n    updateTextInput(session, \r\n                    \"name\",\r\n                    value = \"\"\r\n    )\r\n  })\r\n \r\n  filtered_df <- eventReactive(input$go, {\r\n    df %>% \r\n      filter(name == clean_name() & state == input$state)\r\n  })\r\n  \r\n  output$name_entered <- renderText({\r\n    c(\"You entered:\", input$name)\r\n  })\r\n  \r\n  output$main_table <- renderTable({\r\n    filtered_df()\r\n  })\r\n\r\n}\r\n\r\n\r\n\r\n\r\nhttps://mastering-shiny.org/basic-reactivity.html#reactive-programming↩︎\r\nhttps://mastering-shiny.org/reactivity-objects.html#observers-details↩︎\r\nhttps://mastering-shiny.org/basic-reactivity.html#observers↩︎\r\nhttps://shiny.rstudio.com/reference/shiny/latest/session.html↩︎\r\n",
      "last_modified": "2021-03-16T21:00:11-07:00"
    },
    {
      "path": "resources.html",
      "title": "Resources",
      "description": "An opinionated list of guides or tutorials for Shiny and helping packages\n",
      "author": [],
      "contents": "\r\n\r\nContents\r\nModule Material\r\nShiny\r\nVisualization Packages\r\nDT\r\nOther htmlwidgets\r\n\r\nReactable\r\n\r\n\r\nModule Material\r\nScript templates and intermediate scripts prepared for this module can be forked or downloaded from github.\r\nShiny\r\nShiny Gallery’s Shiny Demo: interactive examples of various Shiny features (individual widgets, layout styles, and reactivity). The source code is displayed as you interact with the examples. It’s a great way to learn!\r\nOfficial Cheatsheet: A two-pager of Shiny utilities.\r\nMastering Shiny Book: A book (in progress) by Hadley Wickham. See the Getting Started section. For those who use the tidyverse, it also includes a section on the latest version of tidy evaluation–essential for programming with packages like dplyr or ggplot2.\r\nVisualization Packages\r\nDT\r\nOther htmlwidgets\r\nReactable\r\nAnother interactive table package. On the surface, basic use of reactable might not be that different than DT, but the ability to create expandable rows and nested tables, and the conditional styling examples really makes this package stand out.\r\nTo see a Shiny app with a reactable table in the wild, see this reactable example, code is available here.\r\n\r\n\r\n\r\n",
      "last_modified": "2021-03-16T21:00:12-07:00"
    },
    {
      "path": "slides.html",
      "title": "Slides",
      "author": [],
      "contents": "\r\n\r\n\r\n\r\nfitvids('.shareagain', {players: 'iframe'});\r\n\r\nShortcut Keys\r\nf: full-screen\r\nEsc: exit full-screen\r\no: tile view\r\n⬅️ ➡️: advance slide\r\n\r\n\r\n\r\n",
      "last_modified": "2021-03-16T21:00:13-07:00"
    },
    {
      "path": "styling.html",
      "title": "Styling",
      "description": "shinythemes, bslib, and CSS in a nutshell\n",
      "author": [],
      "contents": "\r\n\r\nContents\r\nshinythemes\r\nbslib\r\nCSS\r\n\r\nCSS (Cascading Style Sheets) is a language used for describing the style and layout of a document. You can always use CSS, but depending on what you’re trying to accomplish, it may not be easy.\r\n\r\n\r\n\r\nFigure 1: We Bare Bears. https://devrant.com/rants/236669/css-in-a-nutshell.\r\n\r\n\r\n\r\n\r\nWorking with CSS. Sometimes things doesn’t always happen where we want it to happen.\r\nPart of the difficulty is that by default, Shiny utilizes Bootstrap–a CSS framework, so styles are already in place. To override Bootstrap and customize the appearance of your app, try the shinythemes or bslib package.\r\nshinythemes\r\nshinythemes is an easy alternative to the default bootstrap theme that is inherent in Shiny. Depending on the theme, it can change fonts, sizing, and color palettes.\r\n\r\n\r\nlibrary(shinythemes)\r\n\r\n\r\n\r\nAfter loading the library, use the theme selector to try out different themes before committing to one.\r\n\r\n# UI\r\n\r\nui <- fluidPage(\r\n  \r\n  # test different shiny themes with the theme selector\r\n  themeSelector(),\r\n\r\n  \r\n  title,\r\n  src,\r\n  .\r\n  .\r\n  .\r\n)\r\n\r\nApply one of the shiny themes.\r\n\r\n# UI\r\n\r\nui <- fluidPage(\r\n  \r\n  # apply a shiny theme\r\n  theme = shinytheme(\"flatly\"),\r\n  \r\n  title,\r\n  src,\r\n  .\r\n  .\r\n  .\r\n)\r\n\r\nbslib\r\nA recent package, bslib, was designed to make it a little easier to override Bootstrap settings. Unlike shinythemes, fonts and color can be set for different parts of the document.\r\nTo find available Google Fonts see: https://fonts.google.com/\r\n\r\n\r\nlibrary(bslib)\r\n\r\n\r\n\r\n\r\n#UI\r\n\r\nui <- fluidPage(\r\n  \r\n  # use bslib's previewer\r\n  theme = bs_theme() %>% bs_theme_preview(),\r\n\r\n  title,\r\n  src,\r\n  .\r\n  .\r\n  .\r\n)\r\n\r\nAfter testing, customize your theme by setting the arguments in bs_theme().\r\n\r\n#UI\r\n\r\nui <- fluidPage(\r\n  \r\n  # set the arguments\r\n  theme = bs_theme(primary = \"#FF00F3\", \r\n                   heading_font = font_google(\"Pacifico\"), \r\n                   spacer = \"2rem\"),\r\n\r\n  title,\r\n  src,\r\n  .\r\n  .\r\n  .\r\n)\r\n\r\nCSS\r\n\r\n\r\n\r\n",
      "last_modified": "2021-03-16T21:00:14-07:00"
    }
  ],
  "collections": []
}
